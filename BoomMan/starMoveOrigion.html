<!DOCTYPE html>
<html>

<head>
    <title>Page Title</title>
    <script type="text/javascript" src="./kit.js"></script>
    <script>

        class __TIME {
            constructor(rate = 33) {
                let self = this;
                self._timeList = [];
                self._rate = rate;

                self._timer = setInterval(self._calculate.bind(self), rate);
            }

            on(event, id) {
                this._timeList.push({
                    id: id,
                    event: event
                });
            }

            off(id) {
                let list = this._timeList;
                for (const index in list) {
                    let event = list[index];
                    if (event.id == id) {
                        list.splice(index, 1);
                    }
                }
            }

            freeze() {
                clearInterval(this._timer);
            }

            unfreeze() {
                let self = this;
                self._timer = setInterval(self._calculate.bind(self), self._rate);
            }

            _calculate() {
                this._timeList.forEach(element => {
                    element['event']();
                });
            }
        }

        class __WORLD {
            constructor(width, height) {

                let canvas = document.createElement('canvas');
                this._universe = window;
                this._canvas = canvas;
                this._width = width;
                this._height = height;
                this._worldBrush = canvas.getContext("2d");
                this._objectList = [];

                this.loaded = undefined;

                this._drawEffectMap = {};

                this.init();
            }

            init() {
                let self = this;
                TIME.on(() => {
                    if (document && document.body) {
                        document.body.append(self._canvas);
                        self._canvas.style.width = self._width;
                        self._canvas.style.height = self._height;
                        self._canvas.style.position = "absolute";
                        self._canvas.style.top = "0px";
                        self._canvas.style.left = "0px";
                        self._canvas.width = self._width;
                        self._canvas.height = self._height;
                        self.initEvent();
                        TIME.off('createEarth');
                    }
                }, 'createEarth');
            }

            initEvent() {
                let self = this;
                TIME.on(self.clearWorld.bind(self), 'clearWorld');

                if (typeof self.loaded == 'function') {
                    self.loaded();
                }

            }

            clearWorld() {
                this._worldBrush.clearRect(0, 0, this.rangeX, this.rangeY);
            }

            set rangeX(x) {
                this._width = x;
            }

            set rangeY(y) {
                this._height = y;
            }

            get rangeX() {
                return this._width;
            }

            get rangeY() {
                return this._height;
            }

            get earth() {
                return this._canvas;
            }

            add(object) {
                var self = this;
                TIME.off('connectLine');
                if (object._uid == "blackhole") {
                    self._objectList.unshift(object);
                } else {
                    self._objectList.push(object);
                }
                TIME.on(self._checkEffect.bind(self), 'connectLine');
            }

            remove(object) {
                var self = this;
                var index = self._objectList.indexOf(object);
                if (index >= 0) {
                    TIME.off('connectLine');
                    self._objectList.splice(index, 1);
                    object.destroy();
                    TIME.on(self._checkEffect.bind(self), 'connectLine');
                }
            }

            calculateDistance(obj1, obj2) {
                let d = Math.pow((obj2.y - obj1.y), 2) + Math.pow((obj2.x - obj1.x), 2);
                d = Math.sqrt(d);
                return d;
            }

            _checkEffect() {
                let self = this;
                let list = self._objectList.concat();

                let obj1, obj2, temp, range, alpha, distance;
                // reset isCBH
                for (let i = 0; i < list.length; i++) {
                    if (list[i]._uid == 'blackhole') {
                        list[i].isCBH = true;
                    } else {
                        list[i].isCBH = false;
                    }
                }

                while (list.length) {
                    obj1 = list.splice(0, 1)[0];
                    for (let i = 0; i < list.length; i++) {
                        obj2 = list[i];
                        range = obj1.effectRange;
                        distance = WORLD.calculateDistance(obj1, obj2);
                        if (range >= distance) {
                            alpha = (distance <= shadeNumber * range) ? 1 : ((range - distance) / (range - shadeNumber * range));
                            if (obj1.isCBH) {
                                obj2.isCBH = true;
                                WORLD.drawEffectLine(obj1, obj2, alpha, "#F9B4B6");
                                //移行变位
                                temp = list.splice(i, 1)[0];
                                list.unshift(temp);
                            } else {
                                WORLD.drawEffectLine(obj1, obj2, alpha);
                            } // if
                        } // if
                    } // loop
                } // loop
            }

            drawEffectLine(obj1, obj2, alpha, lineColor = "#81D8D0") {
                let self = this;

                alpha = parseInt(alpha * 255).toString(16);
                if(alpha.length == 1){
                    lineColor += ('0' + alpha);
                }else{
                    lineColor += alpha;
                }

                self._worldBrush.lineWidth = 0.5;
                self._worldBrush.strokeStyle = lineColor;
                self._worldBrush.beginPath();
                self._worldBrush.moveTo(obj1.x, obj1.y);
                self._worldBrush.lineTo(obj2.x, obj2.y);
                self._worldBrush.stroke();
                self._worldBrush.closePath();
            }

        }

        class WORLDRULE {
            constructor() {
                let self = this;
                self.context = null;
                self._uid = (uuid++);
                self._x = 0;
                self._y = 0;
                self._orgx = 0;
                self._orgy = 0;
                self._range = 0;
                self.speedX = 0;
                self.speedY = 0;
                self._effectRange = 100;
                this._World = {
                    width: 0,
                    height: 0
                }

                self.initEvent();
            }
            initEvent() {
                let self = this;
                TIME.on(self.calculate.bind(self), 'objectMove' + self._uid);
            }
            get x() {
                return this._x;
            }

            get y() {
                return this._y;
            }

            get speed() {
                return {
                    x: this.speedX,
                    y: this.speedY
                }
            }

            set World(world) {
                this._World = world;
            }

            calculate() {
                let self = this;
                var result, calX, calY;
                if (!self.context) {
                    return;
                }

                result = self.checkHit();
                if (result.indexOf('+x') != -1) {
                    // 触发碰撞后，先移动后，后改速度
                    calX = (2 * (self._World.rangeX - self._range) - self._x - self.speedX);
                    this.addSpeedX(-2 * this.speedX);
                } else if (result.indexOf('-x') != -1) {
                    // 触发碰撞后，先移动后，后改速度
                    calX = (2 * self._range - self.speedX - self._x);
                    this.addSpeedX(-2 * this.speedX);
                } else {
                    calX = self._x + self.speedX;
                }

                if (result.indexOf('+y') != -1) {
                    // 触发碰撞后，先移动后，后改速度
                    calY = (2 * (self._World.rangeY - self._range) - self._y - self.speedY);
                    this.addSpeedY(-2 * this.speedY);
                } else if (result.indexOf('-y') != -1) {
                    // 触发碰撞后，先移动后，后改速度
                    calY = (2 * self._range - self.speedY - self._y);
                    this.addSpeedY(-2 * this.speedY);
                } else {
                    calY = self._y + self.speedY;
                }

                // 移动
                // self.context.clearRect(self._x - self._range, self._y - self._range, 2 * self._range, 2 * self._range);
                self._orgx = self.x;
                self._orgy = self.y;
                self._x = calX;
                self._y = calY;
                self.move();
            }

            addSpeedX(x) {
                // console.log('%s add x Speed: %s', this._uid, x);
                this.speedX += x;
            }

            addSpeedY(y) {
                // console.log('%s add y Speed: %s', this._uid, y);
                this.speedY += y;
            }

            checkHit() {
                let self = this;
                var rangeX = self._World.rangeX - self._range;
                var rangeY = self._World.rangeY - self._range;
                var result = "";
                var resultX = self._x + self.speedX;
                var resultY = self._y + self.speedY;

                if (resultX <= self._range) {
                    result += "-x";
                } else if (resultX >= rangeX) {
                    result += "+x";
                }
                if (resultY <= self._range) {
                    result += "-y";
                } else if (resultY >= rangeY) {
                    result += "+y";
                }

                return result;
            }

        }

        class PLANT extends WORLDRULE {
            constructor(x, y, World) {
                super();
                let self = this;
                self._x = x || 0;
                self._y = y || 0;
                self._World = World || self._World;
                self._range = 1;
                
                self._effectRange = 100;
                // is connect black hole
                self._isCBH = false;
                // is catched black hole
                self._isCBBH = false;
                
                self._connectList = [];
            }

            init() {
                let self = this;
                self.context = self._World.earth.getContext("2d");
                self.context.fillStyle = "#2E81CE"; //等同于fillStyle="rgba(46,129,206,1)";
                self.move();
            }

            move() {
                let self = this;
                self.context.beginPath();
                self.context.arc(self._x, self._y, self._range, 0, 2 * Math.PI);
                self.context.fill();
            }

            get effectRange() {
                return this._effectRange;
            }

            set x(x) {
                this._x = x;
            }

            set y(y) {
                this._y = y;
            }

            get x() {
                return this._x;
            }

            get y() {
                return this._y;
            }

            set uid(uid) {
                let self = this;
                TIME.off('objectMove' + self._uid);
                self._uid = uid;
                TIME.on(self.calculate.bind(self), 'objectMove' + self._uid);
            }

            get uid() {
                return this._uid;
            }

            // isConnectSuperPower
            set isCBH(flag) {
                this._isCBH = flag;
            }

            // isConnectSuperPower
            get isCBH() {
                return this._isCBH;
            }

            addConnect(p) {
                this._connectList.push(p);
            }

            clearConnect() {
                this._connectList = [];
            }

            destroy() {
                let self = this;
                TIME.off('objectMove' + self._uid);
                self.context.fillRect(self._x - self._range, self._y - self._range, 2 * self._range, 2 * self._range);
                self._x = 0;
                self._y = 0;
                self._range = 0;
                self.speedX = 0;
                self.speedY = 0;
                self._effectRange = 100;
            }

        }

        class BLACKHOLE extends PLANT {
            constructor(x, y, World) {
                super(x, y, World);
                this._uid = 'blackhole';
            }
        }

        let randomInt = (min, max) => {
            if (max === undefined) {
                return (Math.random() * min) || randomInt(min);
            } else {
                return (min + Math.random() * (max - min)) || randomInt(max);
            }
        }

        let blackhole = null;

        let mouseMove = (e) => {
            if (!blackhole) {
                blackhole = new BLACKHOLE(e.offsetX, e.offsetY, WORLD);
                blackhole.init();
                WORLD.add(blackhole);
            }
            blackhole.x = e.offsetX;
            blackhole.y = e.offsetY;
        }

        let mouseOut = (e) => {
            WORLD.remove(blackhole);
            blackhole = null;
        }


        const HEIGHT = window.innerHeight;
        const WIDTH = window.innerWidth;
        const TIME = new __TIME();
        const WORLD = new __WORLD(WIDTH, HEIGHT);

        let shadeNumber = 0.8;
        let uuid = 1000;

        WORLD.loaded = () => {

            var pointsNumbers = (parseInt(HEIGHT / 500) + 1) * (parseInt(WIDTH / 500) + 1) * 25;
            console.log("this WORLD is %spx width, %spx height, %s points", WIDTH, HEIGHT, pointsNumbers);
            // 每500px*500px 最少压入25个点
            for (let i = 0; i < pointsNumbers; i++) {
                let p = new PLANT(randomInt(WIDTH), randomInt(HEIGHT), WORLD);
                p.init();
                p.addSpeedX(randomInt(-1, 1));
                p.addSpeedY(randomInt(-1, 1));
                WORLD.add(p);
            }

            WORLD.earth.addEventListener('mousemove', mouseMove);
            WORLD.earth.addEventListener('mouseout', mouseOut);
        }

    </script>
</head>

<body style="width:100%;height:100%;">

</body>

</html>